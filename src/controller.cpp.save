#include <memory>
#include <chrono>
#include <rclcpp/rclcpp.hpp>
#include <bits/stdc++.h>
#include <geometry_msgs/msg/transform_stamped.hpp>
#include "geometry_msgs/msg/twist.hpp"
#include <tf2/LinearMath/Transform.h>
#include <tf2_ros/transform_broadcaster.h>
#include <tf2_ros/transform_listener.h>
#include <tf2/LinearMath/Quaternion.h>
#include <tf2_ros/buffer.h>
#include <tf2/utils.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>

#include "Spi.h"

using namespace mecanum;

Spi spi;
SpiMessage TxMsg, RxMsg;
std::shared_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster;
std::shared_ptr<tf2_ros::Buffer> tf_buffer;
std::shared_ptr<tf2_ros::TransformListener> tf_listener;
rclcpp::Node::SharedPtr node;

float x_threshold=0.5;
float y_threshold=0.5;
float z_threshold=0.5;
float Theta=0.0;

void updatePose()
{   
    
    TxMsg.conf.x = 0;
    TxMsg.conf.y = 0;
    TxMsg.conf.theta = 0;
    

}

void cmdVelCallback(const geometry_msgs::msg::Twist::SharedPtr msg)
{   
    TxMsg.speed.y = (std::clamp(static_cast<float>(msg->linear.x), -x_threshold, x_threshold));
    TxMsg.speed.x = (-1*std::clamp(static_cast<float>(msg->linear.y), -y_threshold, y_threshold));
    TxMsg.speed.w = (std::clamp(static_cast<float>(msg->angular.z), -z_threshold, z_threshold));
    RCLCPP_INFO(node->get_logger(), "Speed: x=%.3f, y=%.3f, theta=%.3f", TxMsg.speed.x, TxMsg.speed.y, TxMsg.speed.w);

}

int main(int argc, char** argv)
{
    
    rclcpp::init(argc, argv);
    node = std::make_shared<rclcpp::Node>("mecanum_controller", rclcpp::NodeOptions().arguments({"--ros-args", "--log-level", "debug"}));
    
    if (!spi.init())
    {
        RCLCPP_ERROR(node->get_logger(), "Failed to initialize SPI");
        rclcpp::shutdown();
        return 1;

    }
    TxMsg.speed = {0, 0, 0};
    TxMsg.conf = {0, 0, 0};
    TxMsg.sync = MESSAGE_SYNC_VALUE;
    
    RxMsg.speed = {0, 0, 0};
    RxMsg.conf = {0, 0, 0};
    RxMsg.sync = MESSAGE_SYNC_VALUE;

    tf_buffer = std::make_shared<tf2_ros::Buffer>(node->get_clock());
    tf_listener = std::make_shared<tf2_ros::TransformListener>(*tf_buffer);
    tf_broadcaster = std::make_shared<tf2_ros::TransformBroadcaster>(node);
    geometry_msgs::msg::TransformStamped transformStamped;
    auto t_act = 0;
    auto t_prev = 0;
    auto t_delta = 0;
    auto cmd_vel_subscriber = node->create_subscription<geometry_msgs::msg::Twist>("/cmd_vel", 10, cmdVelCallback);
    RCLCPP_INFO(node->get_logger(), "Subscribed to /cmd_vel");
    
    spi.transfer(TxMsg, RxMsg);
    rclcpp::Rate loop_rate(10);
    while (rclcpp::ok())
    {


        if(spi.transferSignal())
        {
            if(spi.transfer(TxMsg, RxMsg))
            {   
                t_act = std::chrono::high_resolution_clock::now();
                RCLCPP_INFO(node->get_logger(), "Transmitted speed: x=%.3f, y=%.3f, w=%.3f", TxMsg.speed.x, TxMsg.speed.y, TxMsg.speed.w);
                RCLCPP_INFO(node->get_logger(), "Received speed: x=%.3f, y=%.3f, w=%.3f", RxMsg.speed.x, RxMsg.speed.y, RxMsg.speed.w);
                transformStamped.header.stamp = node->get_clock()->now();
                transformStamped.header.frame_id = "odom";
                transformStamped.child_frame_id = "base_footprint";
                transformStamped.transform.translation.y = - RxMsg.conf.x;
                transformStamped.transform.translation.x = RxMsg.conf.y;
                transformStamped.transform.translation.z = 0.0;
                t_delta = t_act - t_prev;
                Theta=Theta+t_delta*TxMsg.speed.w;
                tf2::Quaternion q;
                q.setRPY(0, 0, Theta);
                transformStamped.transform.rotation.x = q.x();
                transformStamped.transform.rotation.y = q.y();
                transformStamped.transform.rotation.z = q.z();
                transformStamped.transform.rotation.w = q.w();

    auto t_prev = 0;
    auto t_delta = 0;
    auto cmd_vel_subscriber = node->create_subscription<geometry_msgs::msg::Twist>("/cmd_vel", 10, cmdVelCallback);
    RCLCPP_INFO(node->get_logger(), "Subscribed to /cmd_vel");
    
    spi.transfer(TxMsg, RxMsg);
    rclcpp::Rate loop_rate(10);
    while (rclcpp::ok())
    {
        

        if(spi.transferSignal())
        {
            if(spi.transfer(TxMsg, RxMsg))
            {	
		t_act = std::chrono::high_resolution_clock::now();
                RCLCPP_INFO(node->get_logger(), "Transmitted speed: x=%.3f, y=%.3f, w=%.3f", TxMsg.speed.x, TxMsg.speed.y, TxMsg.speed.w);
                RCLCPP_INFO(node->get_logger(), "Received speed: x=%.3f, y=%.3f, w=%.3f", RxMsg.speed.x, RxMsg.speed.y, RxMsg.speed.w);
                transformStamped.header.stamp = node->get_clock()->now();
                transformStamped.header.frame_id = "odom";
                transformStamped.child_frame_id = "base_footprint";
                transformStamped.transform.translation.y = - RxMsg.conf.x;
                transformStamped.transform.translation.x = RxMsg.conf.y;
                transformStamped.transform.translation.z = 0.0;
                t_delta = t_act - t_prev;
		Theta=Theta+t_delta*TxMsg.speed.w;
                tf2::Quaternion q;
                q.setRPY(0, 0, Theta);
                transformStamped.transform.rotation.x = q.x();
                transformStamped.transform.rotation.y = q.y();
                transformStamped.transform.rotation.z = q.z();
                transformStamped.transform.rotation.w = q.w();
                tf_broadcaster->sendTransform(transformStamped);
                RCLCPP_INFO(node->get_logger(), "Received pose: x=%.3f, y=%.3f, theta=%.3f", RxMsg.conf.x, RxMsg.conf.y, RxMsg.conf.theta);
                RCLCPP_INFO(node->get_logger(), "Transmitted pose: x=%.3f, y=%.3f, theta=%.3f", TxMsg.conf.x, TxMsg.conf.y, TxMsg.conf.theta);
 	        t_prev = t_act;   
}
            else
            {
                RCLCPP_INFO(node->get_logger(), "SPI Error");
            }
        }
        else{

            RCLCPP_INFO(node->get_logger(), "SPI transferSignalError");

        }

        rclcpp::spin_some(node);
        loop_rate.sleep();
    }
    tf_buffer.reset();
    tf_listener.reset();
    rclcpp::shutdown();
    return 0;

    
    

}
